#!/bin/bash

# 1. åƒæ•¸è§£æž
DRY_RUN=false
DEEP=false

usage() {
    echo "Usage: clean-orphans [OPTIONS]"
    echo ""
    echo "Safely kill orphaned development processes (PPID=1) to reclaim memory."
    echo ""
    echo "Options:"
    echo "  --deep      Also kill heavy background daemons (Gradle, Kotlin LSP, iOS Simulators)"
    echo "              âš ï¸  May interrupt active builds â€” use --dry-run first to preview"
    echo "  --dry-run   Show what would be killed without actually killing anything"
    echo "  -h, --help  Show this help message"
}

for arg in "$@"; do
    case "$arg" in
        --deep)    DEEP=true ;;
        --dry-run) DRY_RUN=true ;;
        -h|--help) usage; exit 0 ;;
        *) echo "Unknown option: $arg"; usage; exit 1 ;;
    esac
done

echo "ðŸ” Scanning for orphaned development processes..."
$DRY_RUN && echo "  (dry-run mode: no processes will be killed)"

# 2. ä½œæ¥­ç³»çµ±åµæ¸¬
OS="$(uname -s)"

# 3. å®šç¾©é€šç”¨çš„å­¤å…’é€²ç¨‹ç‰¹å¾µ (å¯è¼•æ˜“æ“´å……)
# åŒ…å«å¸¸è¦‹çš„ç¾ä»£ AI é–‹ç™¼å·¥å…· (MCP)ã€å‰ç«¯å·¥å…·èˆ‡è·¨å¹³å°é–‹ç™¼å·¥å…·
ORPHAN_PATTERNS=(
  # AI & MCP Servers (Common)
  "mcp-server|playwright-mcp"
  # AI & MCP Servers (Personal / Custom â€” remove or replace with your own)
  "context7|mobile-mcp"
  # Node.js Wrappers (MCP related)
  "npm exec @playwright|npm exec @mobilenext|npm exec @upstash"
  # Frontend Dev Servers (webpack, vite, next.js, esbuild, turbopack)
  "webpack-dev-server|vite.*--host|next-server|next dev|esbuild.*--serve|turbopack"
  # Dart & Flutter Tooling
  "flutter_tester|dart.*(tooling-daemon|devtools --machine|development-service)"
  # iOS Logging
  "log stream.*Runner"
)

# å°‡é™£åˆ—çµ„åˆæˆæ­£å‰‡è¡¨é”å¼å­—ä¸²
REGEX_PATTERN=$(IFS="|"; echo "${ORPHAN_PATTERNS[*]}")

# 4. é€šç”¨å‡½å¼

# è¨ˆç®—ä¸¦å›žå ±é€²ç¨‹çµ±è¨ˆï¼ˆä¸åŸ·è¡Œ killï¼‰
report_stats() {
    local PIDS="$1"
    local LABEL="$2"

    if [ -z "$PIDS" ]; then
        echo "âœ… No $LABEL found."
        return 1
    fi

    # ps -o rss= å–å¾—è¨˜æ†¶é«” (KB)ï¼Œåœ¨ Linux èˆ‡ macOS çš†å¯é‹ä½œ
    local STATS
    STATS=$(ps -o rss= -p $PIDS 2>/dev/null | awk '{sum+=$1; count++} END {printf "%d|%.2f", count, sum/1024}')
    local COUNT="${STATS%%|*}"
    local MEM="${STATS##*|}"

    echo "ðŸ”ª Killing $COUNT $LABEL (Reclaiming ~$MEM MB)..."
    return 0
}

# é€å‡º SIGTERMï¼Œç­‰å¾…æœ€å¤š 2 ç§’ï¼Œå°æœªé€€å‡ºçš„é€²ç¨‹é€ SIGKILL
graceful_kill() {
    local PIDS="$1"
    [ -z "$PIDS" ] && return

    if $DRY_RUN; then
        echo "   â†’ would kill PIDs: $PIDS"
        return
    fi

    # SIGTERM å…ˆç¦®è²Œè«‹æ±‚é€€å‡º
    echo "$PIDS" | xargs kill 2>/dev/null

    # ç­‰å¾…æœ€å¤š 2 ç§’è®“é€²ç¨‹è‡ªè¡Œé€€å‡º
    local waited=0
    while [ $waited -lt 4 ]; do
        local remaining=""
        for pid in $PIDS; do
            kill -0 "$pid" 2>/dev/null && remaining="$remaining $pid"
        done
        remaining=$(echo "$remaining" | xargs)
        [ -z "$remaining" ] && return
        sleep 0.5
        waited=$((waited + 1))
    done

    # é ‘å›ºé€²ç¨‹ç”¨ SIGKILL å¼·åˆ¶çµ‚çµ
    if [ -n "$remaining" ]; then
        echo "   âš¡ Force killing unresponsive PIDs: $remaining"
        echo "$remaining" | xargs kill -9 2>/dev/null
    fi
}

# è¨ˆç®—çµ±è¨ˆ + å„ªé›…çµ‚çµé€²ç¨‹
kill_and_report() {
    local PIDS="$1"
    local LABEL="$2"
    report_stats "$PIDS" "$LABEL" && graceful_kill "$PIDS"
}

# ç”¨é—œéµå­—æœå°‹ä¸¦æ¸…ç†é€²ç¨‹ï¼ˆç”¨æ–¼æ·±åº¦æ¸…ç†ï¼‰
# ä½¿ç”¨ pgrep -f å–ä»£ ps|grep ç®¡ç·šï¼Œé¿å…è‡ªèº«åŒ¹é…å•é¡Œ
cleanup_by_name() {
    local label="$1"
    local pattern="$2"
    local PIDS
    PIDS=$(pgrep -f "$pattern" 2>/dev/null | xargs)
    kill_and_report "$PIDS" "$label processes"
}

# åªæ¸…ç†å­¤å…’é€²ç¨‹ (PPID=1)ï¼Œç”¨æ–¼å¯èƒ½æ­£åœ¨æ´»èºä½¿ç”¨çš„å·¥å…·ï¼ˆå¦‚ xcodebuildï¼‰
cleanup_orphaned_by_name() {
    local label="$1"
    local pattern="$2"
    local PIDS
    PIDS=$(pgrep -P 1 -f "$pattern" 2>/dev/null | xargs)
    kill_and_report "$PIDS" "$label processes"
}

# 5. å°‹æ‰¾å®‰å…¨çš„å­¤å…’é€²ç¨‹ (PPID=1)
ORPHAN_PIDS=$(ps -eo ppid,pid,command | grep -E "$REGEX_PATTERN" | grep -v grep | awk '$1 == 1 {print $2}')
# adb logcat ä¹Ÿåªæ¸…ç†å­¤å…’ (PPID=1)ï¼Œé¿å…èª¤æ®ºä½¿ç”¨è€…ä¸»å‹•é–‹å•Ÿçš„ logcat
ADB_PIDS=$(ps -eo ppid,pid,command | grep -E 'adb.*logcat' | grep -v grep | awk '$1 == 1 {print $2}')

# åˆä½µéœ€è¦å®‰å…¨æ¸…ç†çš„ PID
PIDS_TO_KILL=""
[ -n "$ORPHAN_PIDS" ] && PIDS_TO_KILL="$ORPHAN_PIDS"
[ -n "$ADB_PIDS" ] && PIDS_TO_KILL="$PIDS_TO_KILL $ADB_PIDS"
PIDS_TO_KILL=$(echo "$PIDS_TO_KILL" | xargs)

if [ -n "$PIDS_TO_KILL" ]; then
    kill_and_report "$PIDS_TO_KILL" "orphaned/stale processes"
    echo "âœ… Safe orphans cleaned."
else
    echo "âœ… No safe orphans found. Clean!"
fi

# 6. æ·±åº¦æ¸…ç†æ¨¡å¼
if $DEEP; then
    echo ""
    echo "âš ï¸ Deep cleanup requested..."

    # è·¨å¹³å°é€šç”¨çš„æ·±åº¦æ¸…ç† (Android, Java, Flutter ç­‰)
    cleanup_by_name "Kotlin LSP" "kotlinLsp"
    cleanup_by_name "Gradle Daemon" "org.gradle.launcher.daemon"
    cleanup_by_name "Flutter Daemon" "flutter_tools.snapshot daemon"
    # xcodebuild åªæ®ºå­¤å…’ (PPID=1)ï¼Œé¿å…ä¸­æ–·æ­£åœ¨é€²è¡Œçš„ build
    cleanup_orphaned_by_name "Orphaned xcodebuild" "xcodebuild"

    # macOS å°ˆç”¨çš„ iOS æ¨¡æ“¬å™¨æ¸…ç†
    if [ "$OS" == "Darwin" ] && command -v xcrun &> /dev/null; then
        SIM_PIDS=$(pgrep -f 'CoreSimulator|Simulator.app' 2>/dev/null | xargs)
        if report_stats "$SIM_PIDS" "iOS Simulator processes"; then
            if ! $DRY_RUN; then
                xcrun simctl shutdown all 2>/dev/null
            else
                echo "   â†’ would run: xcrun simctl shutdown all"
            fi
        fi
    fi

    echo "âœ… Deep cleanup completed."
else
    echo ""
    echo "ðŸ’¡ Tip: Run 'clean-orphans --deep' to also kill heavy background processes like Gradle, Kotlin LSP, and iOS Simulators."
fi
